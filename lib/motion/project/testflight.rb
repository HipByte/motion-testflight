# Copyright (c) 2012, Laurent Sansonetti <lrz@hipbyte.com>
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

unless defined?(Motion::Project::Config)
  raise "This file must be required within a RubyMotion project Rakefile."
end

class TestFlightConfig
  attr_accessor :sdk, :api_token, :team_token, :app_token, :distribution_lists, :notify, :identify_testers

  def initialize(config)
    @config = config
  end

  def sdk=(sdk)
    if @sdk != sdk
      @config.unvendor_project(@sdk)
      @sdk = sdk
      @config.vendor_project(sdk, :static)
      libz = '/usr/lib/libz.dylib'
      @config.libs << libz unless @config.libs.index(libz) 
    end
  end

  def team_token=(team_token)
    @team_token = team_token
    create_launcher
  end

  def app_token=(app_token)
    @app_token = app_token
    create_launcher if team_token
  end

  def identify_testers=(identify_testers)
    @identify_testers = identify_testers
    create_launcher
  end

  def inspect
    {:sdk => sdk, :api_token => api_token, :team_token => team_token, :app_token => app_token, :distribution_lists => distribution_lists}.inspect
  end

  private

  def create_launcher
    return unless team_token
    launcher_code = <<EOF
# This file is automatically generated. Do not edit.

if Object.const_defined?('TestFlight') and !UIDevice.currentDevice.model.include?('Simulator')
  NSNotificationCenter.defaultCenter.addObserverForName(UIApplicationDidFinishLaunchingNotification, object:nil, queue:nil, usingBlock:lambda do |notification|
  #{'TestFlight.setDeviceIdentifier(UIDevice.currentDevice.uniqueIdentifier)' if identify_testers}
  TestFlight.takeOff('#{app_token || team_token}')
  end)
end
EOF
    launcher_file = './app/testflight_launcher.rb'
    if !File.exist?(launcher_file) or File.read(launcher_file) != launcher_code
      File.open(launcher_file, 'w') { |io| io.write(launcher_code) }
    end
    files = @config.files.flatten
    files << launcher_file unless files.find { |x| File.expand_path(x) == File.expand_path(launcher_file) }
  end
end

module Motion; module Project; class Config

  attr_accessor :testflight_mode

  variable :testflight

  def testflight
    @testflight ||= TestFlightConfig.new(self)
    yield @testflight if block_given? && testflight?
    @testflight
  end

  def testflight?
    @testflight_mode == true
  end

end; end; end

namespace 'testflight' do
  desc "Submit an archive to TestFlight"
  task :submit do

    App.config_without_setup.testflight_mode = true

    # Retrieve configuration settings.
    prefs = App.config.testflight
    App.fail "A value for app.testflight.api_token is mandatory" unless prefs.api_token
    App.fail "A value for app.testflight.team_token is mandatory" unless prefs.team_token
    distribution_lists = (prefs.distribution_lists ? prefs.distribution_lists.join(',') : nil)
    notes = ENV['notes']
    App.fail "Submission notes must be provided via the `notes' environment variable. Example: rake testflight notes='w00t'" unless notes

    Rake::Task["archive:distribution"].invoke
  
    # An archived version of the .dSYM bundle is needed.
    app_dsym = App.config.app_bundle_dsym('iPhoneOS')
    app_dsym_zip = app_dsym + '.zip'
    if !File.exist?(app_dsym_zip) or File.mtime(app_dsym) > File.mtime(app_dsym_zip)
      Dir.chdir(File.dirname(app_dsym)) do
        sh "/usr/bin/zip -q -r \"#{File.basename(app_dsym)}.zip\" \"#{File.basename(app_dsym)}\""
      end
    end  
  
    curl = "/usr/bin/curl http://testflightapp.com/api/builds.json -F file=@\"#{App.config.archive}\" -F dsym=@\"#{app_dsym_zip}\" -F api_token='#{prefs.api_token}' -F team_token='#{prefs.team_token}' -F notes=\"#{notes}\" -F notify=#{prefs.notify ? "True" : "False"}"
    curl << " -F distribution_lists='#{distribution_lists}'" if distribution_lists
    App.info 'Run', curl
    sh curl
  end

  desc "Records if the device build is created in testflight mode, so some things can be cleaned up between mode switches"
  task :record_mode do
    testflight_mode = App.config_without_setup.testflight_mode ? "True" : "False"

    platform = 'iPhoneOS'
    bundle_path = App.config.app_bundle(platform)
    build_dir = File.join(App.config.versionized_build_dir(platform))
    FileUtils.mkdir_p(build_dir)
    previous_testflight_mode_file = File.join(build_dir, '.testflight_mode')

    previous_testflight_mode = "False"
    if File.exist?(previous_testflight_mode_file)
      previous_testflight_mode = File.read(previous_testflight_mode_file).strip
    end
    if previous_testflight_mode != testflight_mode
      App.info "Testflight", "Cleaning executable, Info.plist, and PkgInfo for mode change (was: #{previous_testflight_mode}, now: #{testflight_mode})"
      [
        App.config.app_bundle_executable(platform), # main_exec
        File.join(bundle_path, 'Info.plist'), # bundle_info_plist
        File.join(bundle_path, 'PkgInfo') # bundle_pkginfo
      ].each do |path|
        rm_rf(path) if File.exist?(path)
      end
    end
    File.open(previous_testflight_mode_file, 'w') do |f|
      f.write testflight_mode
    end
  end
end

desc 'Same as testflight:submit'
task 'testflight' => 'testflight:submit'

# record testflight mode before every device build
task 'build:device' => 'testflight:record_mode'
